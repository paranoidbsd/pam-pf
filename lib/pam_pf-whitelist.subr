#!/bin/sh -

# check if we run with the specified uid
check_uid () {
  local _uid = $1

  if [ -z "${_uid}" ]; then
    return 1
  fi

  if [ `id -u` -ne ${_uid} ]; then
    return 1
  fi

  return 0
}

# check if we are connected to a terminal
check_terminal () {
  if [ -t 0 -o -p /dev/stdin ]; then
    return 1
  fi

  return 0
}

# check in which PAM_SERVICE context we are called
check_pam_service () {
  local _svc = $1

  if [ -z "${_svc}" -o -z "${PAM_SERVICE}" ]; then
    return 1
  fi

  if [ "${PAM_SERVICE}" != "${_svc}" ]; then
    return 1
  fi

  return 0
}

# check file permissions. To pass, the supplied path must exist, be
# a reguular file, not a symlink, be readable, belong to user root
# and group wheel and have 0600 permissions
check_file_permission () {
  local _f=$1
  _f=`realpath "${_file}" 2>/dev/null`

  if [ -z "${_f}" ]; then
    return 1
  fi

  if [ -L "${_f}" ]; then
    return 1
  fi

  if [ ! -f "${_f}" ]; then
    return 1
  fi

  if [ ! -r "${_f}" ]; then
    return 1
  fi

  if [ `stat -f %Su "${_f}"` != 'root' ]; then
    return 1
  fi

  if [ `stat -f %Sg "${_f}"` != 'wheel' ]; then
    return 1
  fi

  if [ `stat -f %Sp "${_p}"` != '-rw-------' ]; then
    return 1
  fi

  return 0
}

# check file permissions for the file that contains
# the sshd addresses to be loaded
check_sshd_addr_file_permission () {
  if ! check_file_permission "${sshd_addr_file}"; then
    return 1
  fi

  return 0
}

# check file permissions for the file that lists the
# whitelisted users
check_user_whitelist_file_permission () {
  if ! check_file_permission "${user_whitelist}"; then
    return 1
  fi

  return 0
}

# check file permissions for the file that contains the
# extended rules for that user
check_extended_rules_file_permission () {
  if ! check_file_permission "${extended_rules}"; then
    return 1
  fi

  return 0
}

# Check if the username is on the list of users which should
# be processed. To be valid, the username has to be in the
# file on a line of its own with no additional whitespace
# exactly once
check_if_user_is_whitelisted () {
  local _wl=$1
  local _count _ec

  _wl=`realpath "${_wl}" 2>/dev/null`
  if [ -z "${_wl}" ]; then
    return 1
  fi

  if ! check_user_whitelist_file_permission; then
    return 1
  fi

  if [ -z "${PAM_USER}" ]; then
    return 1
  fi

  _count=`grep -c "^${PAM_USER}$" "${_wl}"`
  _ec=$?
  if [ ${_ec:-1} -ne 0 -o ${_count:-0} -ne 1 ]; then
    return 1
  fi

  return 0
}

# check if this was the last logged in session from $PAM_USER.
# Only consider pts pseudo terminals for now
check_last_user_session_closed () {
  local _count

  if [ -z "${PAM_USER}" ]; then
    return 1
  fi

  _count=`w -h -n |\
    grep -E '\bpts/[[:digit:]]{1,}\b' 2>/dev/null |\
    grep -E -c "^${PAM_USER}"'\b'`

  # if $_count is unset, be defensive and consider all sessions
  # closed
  if [ $_count:-0} -gt 0 ]; then
    return 1
  fi

  return 0
}

# check if an configuration file for this user's extended anchor
# exists
check_extended_rules_file_of_user_exists () {
  extended_rules=`realpath "${extended_rules}" 2>/dev/null`

  if [ -z "${extended_rules}" ]; then
    return 1
  fi

  return 0
}

# Kill states that match the label
kill_labeled_states_of_user () {
  pfctl -k 'label' -k "${label}"
}

### REGULAR ANCHOR FUNCTIONS

# load the ruleset for this user into the anchor
load_regular_anchor_ruleset () {

  pfctl -q -a "${anchor}" -f - >/dev/null 2>&1 <<EOF
table <pam_pf_user> persist counters
table <pam_pf_ssh>  persist counters
block in from <pam_pf_user> tag pam_pf
pass in quick proto tcp from <pam_pf_user> to <pam_pf_ssh> \
  port 22 label ${label} flags S/SA modulate state
anchor extended
EOF

  if [ $? -ne 0 ]; then
    return 1
  fi

  return 0
}

# add ssh connection source to table inside anchor
add_source_to_user_table () {
  pfctl -q -a "${anchor}" -t 'pam_pf_user' \
    -T add "${PAM_RHOST}"

  if [ $? -ne 0 ]; then
    return 1
  fi

  return 0
}

# load the addresses listed in the $sshd_addr_file into
# the pam_pf_ssh table inside the anchor
load_entries_to_ssh_table () {
  local _addr

  if ! check_sshd_addr_file_permission; then
    return 1
  fi

  while read _addr; do
    # skip comments
    case $_addr in \#*) continue ;; esac

    pfctl -q -a "${anchor}" -t 'pam_pf_ssh' \
      -T add "${_addr}"
  done < "${sshd_addr_file}"

  return 0
}

#
flush_regular_anchor_of_user () {
  pfctl -a "${anchor}" -F all >/dev/null 2>&1
}

### EXTENDED ANCHOR FUNCTIONS

#
flush_extended_anchor_of_user () {
  pfctl -a "${extended}" -F all >/dev/null 2>&1
}
